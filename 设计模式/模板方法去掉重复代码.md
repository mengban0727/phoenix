## 背景

亿欧数据平台，数据存储在es中，不同功能模块从不同的索引中查询数据，且都有列表查询，批量查询，分页查询，单条查询，获取索引名称的逻辑，不同的是，从es中查询到的数据，需要进行实体类的转换，而每种索引的转换规则又不同，因此，使用模板方法来简化代码。

* 声明一个抽象类，定义骨架流程，将相同逻辑的代码抽取出来，再将不同逻辑的代码定义成抽象方法放到骨架
* 子类实现抽象方法

## BasicSearchRepo抽象类

```java
public abstract class BasicSearchRepo<T> {

    @Resource
    protected RestHighLevelClient restHighLevelClient;

    //列表查询
    public List<T> getList(SearchSourceBuilder searchSourceBuilder) {
        List<T> resList = new ArrayList<>();
        Class<T> tClass = (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass())
            .getActualTypeArguments()[0];
        SearchRequest searchRequest = new SearchRequest(getESIndexName(tClass));
        searchSourceBuilder.trackTotalHitsUpTo(IntelligenceConstants.TRACK_TOTAL_TITS);
        searchRequest.source(searchSourceBuilder);
        try {
            SearchResponse searchResponse = restHighLevelClient
                .search(searchRequest, RequestOptions.DEFAULT);
            if (RestStatus.OK.equals(searchResponse.status())
                && searchResponse.getHits().getTotalHits().value > 0) {
                for (SearchHit hit : searchResponse.getHits()) {
                    T t = JSON.parseObject(hit.getSourceAsString(), tClass);
                    //不同逻辑
                    trans(t);
                    resList.add(t);
                }
            }
        } catch (Exception e) {
            log.error(e.toString());
        }

        return resList;
    }
    
    public PageResponse<T> getPage(SearchSourceBuilder searchSourceBuilder) {
        return getPage(searchSourceBuilder, IntelligenceConstants.TRACK_TOTAL_TITS);
    }
    
    //分页查询
    public PageResponse<T> getPage(SearchSourceBuilder searchSourceBuilder, int trackTotalHits) {
        PageResponse<T> resPageResponse = new PageResponse<>();
        List<T> dataList = new ArrayList<>();
        resPageResponse.setRecords(dataList);
        Class<T> tClass = (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass())
            .getActualTypeArguments()[0];
        SearchRequest searchRequest = new SearchRequest(getESIndexName(tClass));
        searchSourceBuilder.trackTotalHitsUpTo(trackTotalHits);
        searchRequest.source(searchSourceBuilder);
        SearchResponse searchResponse;
        try {
            searchResponse = restHighLevelClient
                .search(searchRequest, RequestOptions.DEFAULT);
            if (RestStatus.OK.equals(searchResponse.status())
                && searchResponse.getHits().getTotalHits().value > 0) {
                SearchHits hits = searchResponse.getHits();
                for (SearchHit hit : hits) {
                    T t = JSON.parseObject(hit.getSourceAsString(), tClass);
                    trans(t);
                    dataList.add(t);
                }
                long total = searchResponse.getHits().getTotalHits().value;
                resPageResponse.setTotal(total);
            }
        } catch (IOException e) {
            log.error(e.toString());
        }

        return resPageResponse;
    }

    //批量查询
    public Map<String, T> getMap(SearchSourceBuilder searchSourceBuilder) {
        Map<String, T> resMap = new HashMap<>();
        Class<T> tClass = (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass())
            .getActualTypeArguments()[0];
        SearchRequest searchRequest = new SearchRequest(getESIndexName(tClass));
        searchSourceBuilder.trackTotalHitsUpTo(IntelligenceConstants.TRACK_TOTAL_TITS);
        searchRequest.source(searchSourceBuilder);
        try {
            SearchResponse searchResponse = restHighLevelClient
                .search(searchRequest, RequestOptions.DEFAULT);
            if (RestStatus.OK.equals(searchResponse.status())
                && searchResponse.getHits().getTotalHits().value > 0) {
                SearchHits hits = searchResponse.getHits();
                String esField = getESUniqueField(tClass);
                for (SearchHit hit : hits) {
                    T t = JSON.parseObject(hit.getSourceAsString(), tClass);
                    trans(t);
                    resMap.put((String) ClassUtil.getFieldValueByName(esField, t), t);
                }
            }
        } catch (IOException e) {
            log.error(e.toString());
        }
        return resMap;
    }

    //单条查询
    public T getOne(SearchSourceBuilder searchSourceBuilder) {
        Class<T> tClass = (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass())
            .getActualTypeArguments()[0];
        SearchRequest searchRequest = new SearchRequest(getESIndexName(tClass));
        searchRequest.source(searchSourceBuilder);
        try {
            SearchResponse searchResponse = restHighLevelClient
                .search(searchRequest, RequestOptions.DEFAULT);
            SearchHits hits = searchResponse.getHits();
            if (RestStatus.OK.equals(searchResponse.status())
                && hits.getTotalHits().value > 0) {
                int length = hits.getHits().length;
                if (length > 1) {
                    log.error("数据存在问题，这里应命中一条记录，现在命中条目数=" + length);
                }

                SearchHit hit = hits.getAt(0);
                T t = JSON.parseObject(hit.getSourceAsString(), tClass);
                trans(t);
                return t;
            }
        } catch (Exception e) {
            log.error(e.toString());
        }
        return null;
    }

   /**
   * 抽象方法，不同逻辑转换规则
   *
   * @param t ES实体
   */
    protected void trans(T t) {

    }

    /**
   * 根据实体类获取索引名称
   *
   * @param tClass ES实体类
   */
    private String getESIndexName(Class<T> tClass) {
        ESIndexName annotation = tClass.getAnnotation(ESIndexName.class);
        String indexName = annotation.value();
        if (StringUtils.isNotEmpty(indexName)) {
            return indexName;
        }
        throw new ServiceException(ResultCode.NOT_FOUND, "索引名称未知");
    }

    /**
   * 根据实体类获取文档唯一标识字段
   *
   * @param tClass ES实体类
   */
    private String getESUniqueField(Class<T> tClass) {
        String esUniqueField = null;
        Field[] fields = tClass.getDeclaredFields();
        for (Field field : fields) {
            field.setAccessible(true);
            ESId esId = field.getAnnotation(ESId.class);
            if (esId == null) {
                continue;
            }
            esUniqueField = field.getName();
        }
        return esUniqueField;
    }
}
```

## IndexChartSearchRepo子类

```java
public class IntelligenceSearchRepo extends BasicSearchRepo<IntelligenceDto> {
    @Override
    public void trans(IndexChartDto indexChartDto) {
        indexChartDto.setAccountFreqStr(AccountFreqEnum.getFreqStr(indexChartDto.getAccountFreq()));
        String indexUnit = indexChartDto.getIndexUnit();
        indexChartDto
            .setIndexLevelUnit(
            IndexValueLevelEnum.getLevelStr(indexChartDto.getIndexValueLevel()) + (indexUnit == null
                                                                                   ? "" : indexUnit));
        // 当图形为饼状图或环形图时，展示数据标签
        int chartType = indexChartDto.getChartType();
        if (chartType == 6 || chartType == 7) {
            indexChartDto.setDataShow(1);
        }
    }
    //其他方法
}
```

## ProductSearchRepo子类

```java
public class ProductSearchRepo extends BasicSearchRepo<CompanyProductInfo> {
    @Override
    public void trans(CompanyProductInfo companyProductInfo) {
        for (OperatingStatusEnum value : OperatingStatusEnum.values()) {
            if (value.getStatus().equals(companyProductInfo.getOperatingStatus())) {
                companyProductInfo.setOperatingStatusStr(value.getRunningStatus());
                break;
            }
        }
    }
    //其他方法
}
```



## 参考

- [应用设计模式优化代码](https://www.modb.pro/db/425893)