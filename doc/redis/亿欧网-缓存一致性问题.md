## 场景1

分析师在亿欧同学后台发布文章后，在前台亿欧网上能进行查看，访问亿欧网的文章时，我们对每个页面的热点数据，文章快讯等详情相关部分加了缓存，采用了cache-aside模式，先查缓存，缓存查询不到时，再查询数据库将结果缓存在redis中，并设置了过期时间。这时，分析师在亿欧同学后台更改文章后，亿欧网展示给用户查看的还是原来的旧数据，如何解决？

## 上报表和消息队列

数据部门有maxwell监听binlog事件，会将变更都写入到上报表中，亿欧网有定时任务，读取上报表中文章的数据，同步到阿里云的开放搜索中，然后删除同步完成的数据。在任务中删除对应文章变更的缓存

除了数据部门，开发部门也部署了canal将binlog日志写入到mq消息队列中，消费端也会同步数据到es中，在此处也可以根据id删除缓存。



## 场景2

> 列表总数和详情页总数短暂不一致的情况，通常的做法是异步统计后更新总数，达到最终一致

订阅总数（列表展示）、订阅明细统计数量（详情页展示）、缓存，三个存储数据一致性考虑。

1. 先写订阅明细，删除订阅总数缓存
2. 查询缓存时将订阅明细统计数量更新到订阅总数和缓存
3. 异步统计订阅明细数量更新订阅总数，保证最终一致

```java
Object cacheObject = redisUtil.get(cacheKey);
if (cacheObject != null) {
    return (Integer) cacheObject;
}
int reportSubNum = getReportSubNum(reportId);
//情况1. 两个线程，读线程来时，缓存失效，读取到旧订阅数量，订阅线程又更新了订阅数据，此时报告表的订阅数量和订阅表统计数量不一致
//情况2. 两个线程，同理，写入缓存的也是旧数据
updateReportSubNum(reportId, reportSubNum);
String seconds = RandomHelper.getRandom(100, 300);

//情况3.三个线程情况， 两个读线程同时到来，缓存失效，其中第一个读取到旧订阅数量，第三个订阅线程更新了订阅数据，
//第二个读线程读到了新的订阅数量先更新了数据库，然后第一个读线程更新数据库，报告表和订阅表统计数量不一致
//写入缓存可能是旧数据，也可能是新数据
redisUtil.set(cacheKey, reportSubNum, YiouConstants.EXPIRE_ONE_DAY + Long.parseLong(seconds),
              TimeUnit.SECONDS);
return calNum;
```

总结：缓存失效时，同时有更新操作，数据会出现短暂不一致，保证最终一致性即可，不要过度纠结强一致性问题，根据业务是否能够接受短暂不一致性。

## 拓展一致性问题

### 更新缓存异常时问题

* 先更新缓存，更新数据库失败，产生不一致

* 先更新数据库，更新缓存失败，产生不一致

### 更新缓存并发时问题

* 两个线程先更新缓存，更新数据库顺序错乱

* 两个线程先更新数据库，更新缓存顺序错乱

### 删除缓存异常时问题

* 先删缓存，更新数据库操作失败，没关系

* 先更新数据库，删除缓存失败，产生不一致

### 删除缓存并发时问题

* 先删缓存，还没更新数据库时，读操作将旧数据写入缓存，数据不一致

* 缓存失效时，读取数据库旧数据，更新线程更新数据库删除缓存，读线程将旧数据写入缓存，数据不一致。（概率低）

### 保证删除缓存成功-重试

* 应用中将删除缓存消息写入队列
* 订阅数据库变更，删除缓存

### 读写分离时主从延迟不一致

主库更新删掉缓存，读线程发现缓存没有，读取从库写入旧数据

### 延迟删除缓存

更新数据库后，等待主从同步完成再删除缓存

## 参考

[缓存和数据一致性问题](https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd)

